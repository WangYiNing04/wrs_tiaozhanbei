# ç›¸æœºåæ ‡ç³»åˆ°ä¸–ç•Œåæ ‡ç³»è½¬æ¢è¯¦è§£

## ğŸ¯ è½¬æ¢åŸç†

åœ¨ `manual_calib_piper_fixed_eye_camera.py` ä¸­ï¼Œç›¸æœºåæ ‡ç³»åˆ°ä¸–ç•Œåæ ‡ç³»çš„è½¬æ¢æ˜¯é€šè¿‡**é½æ¬¡å˜æ¢çŸ©é˜µ**å®ç°çš„ã€‚

## ğŸ”§ æ ¸å¿ƒè½¬æ¢å‡½æ•°

### 1. ä¸»è¦è½¬æ¢å‡½æ•°ï¼š`align_pcd()`

```python
def align_pcd(self, pcd):
    """
    For fixed eye camera, the calibration matrix directly transforms camera points to world frame
    :param pcd: point cloud in camera frame
    :return: point cloud in world frame
    """
    # The calibration matrix is camera-to-world transformation
    c2w_mat = self._init_calib_mat
    return rm.transform_points_by_homomat(c2w_mat, points=pcd)
```

### 2. åº•å±‚å˜æ¢å‡½æ•°ï¼š`transform_points_by_homomat()`

```python
def transform_points_by_homomat(homomat: np.ndarray, points: np.ndarray):
    """
    do homotransform on a point or an array of points using pos
    :param homomat: 4x4é½æ¬¡å˜æ¢çŸ©é˜µ
    :param points: 1x3 æˆ– nx3 ç‚¹äº‘æ•°ç»„
    :return: å˜æ¢åçš„ç‚¹äº‘
    """
    if points.ndim == 1:
        # å•ä¸ªç‚¹çš„æƒ…å†µ
        homo_point = np.insert(points, 3, 1)  # æ·»åŠ é½æ¬¡åæ ‡ [x, y, z, 1]
        return np.dot(homomat, homo_point)[:3]  # çŸ©é˜µä¹˜æ³•åå–å‰3ç»´
    else:
        # å¤šä¸ªç‚¹çš„æƒ…å†µ
        homo_points = np.ones((4, points.shape[0]))  # åˆ›å»ºé½æ¬¡åæ ‡çŸ©é˜µ
        homo_points[:3, :] = points.T[:3, :]  # å¡«å……ç‚¹äº‘æ•°æ®
        transformed_points = np.dot(homomat, homo_points).T  # çŸ©é˜µä¹˜æ³•
        return transformed_points[:, :3]  # è¿”å›å˜æ¢åçš„å‰3ç»´åæ ‡
```

## ğŸ“ é½æ¬¡å˜æ¢çŸ©é˜µç»“æ„

### å˜æ¢çŸ©é˜µæ ¼å¼
```
T_c2w = [R3x3  t3x1]  = [r11  r12  r13  tx]
        [0     1   ]    [r21  r22  r23  ty]
                        [r31  r32  r33  tz]
                        [0    0    0    1 ]
```

å…¶ä¸­ï¼š
- **R3x3**: 3Ã—3æ—‹è½¬çŸ©é˜µï¼Œè¡¨ç¤ºç›¸æœºåæ ‡ç³»ç›¸å¯¹äºä¸–ç•Œåæ ‡ç³»çš„å§¿æ€
- **t3x1**: 3Ã—1å¹³ç§»å‘é‡ï¼Œè¡¨ç¤ºç›¸æœºåæ ‡ç³»åŸç‚¹åœ¨ä¸–ç•Œåæ ‡ç³»ä¸­çš„ä½ç½®

### åˆå§‹å˜æ¢çŸ©é˜µ
```python
# é»˜è®¤åˆå§‹å˜æ¢çŸ©é˜µï¼ˆç›¸æœºåœ¨æœºå™¨äººå‰æ–¹1ç±³ï¼Œé«˜åº¦1ç±³ï¼Œå‘ä¸‹çœ‹ï¼‰
init_mat = np.array([
    [1, 0, 0, 0],    # Xè½´ï¼šä¸–ç•Œåæ ‡ç³»Xè½´æ–¹å‘
    [0, 1, 0, 0],    # Yè½´ï¼šä¸–ç•Œåæ ‡ç³»Yè½´æ–¹å‘  
    [0, 0, 1, 1],    # Zè½´ï¼šä¸–ç•Œåæ ‡ç³»Zè½´æ–¹å‘ï¼Œé«˜åº¦1ç±³
    [0, 0, 0, 1]     # é½æ¬¡åæ ‡
])
```

## ğŸ”„ è½¬æ¢è¿‡ç¨‹è¯¦è§£

### æ•°å­¦å…¬å¼
å¯¹äºç›¸æœºåæ ‡ç³»ä¸­çš„ç‚¹ `P_camera = [x_c, y_c, z_c]`ï¼Œè½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»çš„å…¬å¼ä¸ºï¼š

```
P_world = R * P_camera + t
```

åœ¨é½æ¬¡åæ ‡ç³»ä¸­ï¼š
```
[P_world]   [R  t] [P_camera]
[   1   ] = [0  1] [   1    ]
```

### å…·ä½“å®ç°æ­¥éª¤

1. **æ·»åŠ é½æ¬¡åæ ‡**ï¼š
   ```python
   # å°†3Dç‚¹è½¬æ¢ä¸ºé½æ¬¡åæ ‡
   P_homo = [x_c, y_c, z_c, 1]
   ```

2. **çŸ©é˜µä¹˜æ³•**ï¼š
   ```python
   # åº”ç”¨å˜æ¢çŸ©é˜µ
   P_world_homo = T_c2w * P_homo
   ```

3. **æå–3Dåæ ‡**ï¼š
   ```python
   # å–å‰3ç»´ä½œä¸ºä¸–ç•Œåæ ‡ç³»ä¸­çš„ç‚¹
   P_world = P_world_homo[:3]
   ```

## ğŸ® æ‰‹åŠ¨æ ‡å®šè¿‡ç¨‹

### å¹³ç§»è°ƒæ•´
```python
def move_adjust(self, dir, dir_global, key_name=None):
    # ç›´æ¥è°ƒæ•´å˜æ¢çŸ©é˜µçš„å¹³ç§»éƒ¨åˆ†
    self._init_calib_mat[:3, 3] = self._init_calib_mat[:3, 3] + dir_global * self.move_resolution
```

### æ—‹è½¬è°ƒæ•´
```python
def rotate_adjust(self, dir, dir_global, key_name=None):
    # é€šè¿‡è½´è§’æ—‹è½¬æ›´æ–°æ—‹è½¬çŸ©é˜µ
    self._init_calib_mat[:3, :3] = np.dot(
        rm.rotmat_from_axangle(dir_global, self.rotation_resolution),
        self._init_calib_mat[:3, :3]
    )
```

## ğŸ¯ é”®ç›˜æ§åˆ¶æ˜ å°„

| æŒ‰é”® | åŠŸèƒ½ | è°ƒæ•´æ–¹å‘ |
|------|------|----------|
| W/S | Xè½´å¹³ç§» | ç›¸æœºå‰åç§»åŠ¨ |
| A/D | Yè½´å¹³ç§» | ç›¸æœºå·¦å³ç§»åŠ¨ |
| Q/E | Zè½´å¹³ç§» | ç›¸æœºä¸Šä¸‹ç§»åŠ¨ |
| Z/X | ç»•Xè½´æ—‹è½¬ | ç›¸æœºä¿¯ä»° |
| C/V | ç»•Yè½´æ—‹è½¬ | ç›¸æœºåèˆª |
| B/N | ç»•Zè½´æ—‹è½¬ | ç›¸æœºæ»šè½¬ |

## ğŸ“Š å®é™…åº”ç”¨ç¤ºä¾‹

### åœ¨detect.pyä¸­çš„åº”ç”¨
```python
# 1. è·å–ç›¸æœºç‚¹äº‘ï¼ˆç›¸æœºåæ ‡ç³»ï¼‰
pcd, pcd_color, depth_img, color_img = pipeline.get_pcd_texture_depth()

# 2. è½¬æ¢åˆ°ä¸–ç•Œåæ ‡ç³»
pcd = self.align_pcd(pcd)  # è°ƒç”¨ç›¸æœºåˆ°ä¸–ç•Œåæ ‡ç³»çš„è½¬æ¢

# 3. åœ¨ä¸–ç•Œåæ ‡ç³»ä¸­è¿›è¡Œåç»­å¤„ç†
cropped_pcd, original_count, cropped_count = self.crop_pointcloud_world(
    pcd, 
    x_range=(0, 0.6), 
    y_range=(0, -0.6), 
    z_range=(0.07, 0.08)
)
```

## ğŸ” å…³é”®ç‰¹ç‚¹

### 1. å›ºå®šçœ¼ç›¸æœºé…ç½®
- ç›¸æœºå›ºå®šåœ¨ä¸–ç•Œåæ ‡ç³»ä¸­
- å˜æ¢çŸ©é˜µç›´æ¥è¡¨ç¤ºç›¸æœºåˆ°ä¸–ç•Œçš„å˜æ¢
- ä¸éœ€è¦è€ƒè™‘æœºå™¨äººè¿åŠ¨

### 2. å®æ—¶æ ‡å®š
- é€šè¿‡é”®ç›˜å®æ—¶è°ƒæ•´å˜æ¢çŸ©é˜µ
- å¯è§†åŒ–åé¦ˆå¸®åŠ©æ ‡å®š
- è‡ªåŠ¨ä¿å­˜æ ‡å®šç»“æœ

### 3. é½æ¬¡åæ ‡å˜æ¢
- ä½¿ç”¨4Ã—4é½æ¬¡å˜æ¢çŸ©é˜µ
- æ”¯æŒæ—‹è½¬å’Œå¹³ç§»çš„å¤åˆå˜æ¢
- é«˜æ•ˆçš„å‘é‡åŒ–è®¡ç®—

## ğŸ‰ æ€»ç»“

ç›¸æœºåæ ‡ç³»åˆ°ä¸–ç•Œåæ ‡ç³»çš„è½¬æ¢é€šè¿‡ä»¥ä¸‹æ­¥éª¤å®ç°ï¼š

1. **è·å–æ ‡å®šçŸ©é˜µ**ï¼šé€šè¿‡æ‰‹åŠ¨æ ‡å®šè·å¾—ç›¸æœºåˆ°ä¸–ç•Œçš„å˜æ¢çŸ©é˜µ
2. **é½æ¬¡åæ ‡è½¬æ¢**ï¼šå°†3Dç‚¹è½¬æ¢ä¸ºé½æ¬¡åæ ‡
3. **çŸ©é˜µä¹˜æ³•**ï¼šåº”ç”¨å˜æ¢çŸ©é˜µè¿›è¡Œåæ ‡å˜æ¢
4. **æå–ç»“æœ**ï¼šä»é½æ¬¡åæ ‡ä¸­æå–3Dä¸–ç•Œåæ ‡

è¿™ç§æ–¹æ³•çš„ä¼˜åŠ¿æ˜¯ï¼š
- **ç›´è§‚**ï¼šå˜æ¢çŸ©é˜µç›´æ¥è¡¨ç¤ºç›¸æœºä¸ä¸–ç•Œåæ ‡ç³»çš„å…³ç³»
- **é«˜æ•ˆ**ï¼šä½¿ç”¨å‘é‡åŒ–è®¡ç®—å¤„ç†å¤§é‡ç‚¹äº‘æ•°æ®
- **çµæ´»**ï¼šæ”¯æŒå®æ—¶è°ƒæ•´å’Œæ ‡å®š
- **å‡†ç¡®**ï¼šé€šè¿‡æ‰‹åŠ¨æ ‡å®šå¯ä»¥è·å¾—é«˜ç²¾åº¦çš„å˜æ¢å…³ç³»




